<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026 | Cinematic Finale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body, html { width: 100%; height: 100%; background: #000; overflow: hidden; }
        canvas { position: fixed; top: 0; left: 0; width: 100vw !important; height: 100vh !important; z-index: 1; }
        .netflix-red { color: #E50914; }
        .netflix-font { font-family: 'Bebas Neue', cursive; letter-spacing: 0.15em; }
        .glow-red { filter: drop-shadow(0 0 15px rgba(229, 9, 20, 0.8)); }
        #ui-layer { position: relative; z-index: 10; width: 100%; height: 100%; pointer-events: none; }
        .bar { position: fixed; left: 0; width: 100%; height: 8vh; background: black; z-index: 100; }
        #start-screen { position: fixed; inset: 0; background: black; z-index: 1000; cursor: pointer; display: flex; align-items: center; justify-content: center; pointer-events: auto; }
        #flash { position: fixed; inset: 0; background: white; opacity: 0; pointer-events: none; z-index: 500; }
    </style>
</head>
<body>

    <div id="flash"></div>
    <div class="bar top-0"></div>
    <div class="bar bottom-0"></div>

    <div id="start-screen">
        <div class="text-center px-10">
            <h1 class="netflix-font text-8xl md:text-9xl netflix-red animate-pulse">N</h1>
            <p class="mt-4 tracking-[0.4em] text-[10px] uppercase opacity-40 text-white">Press to Enter 2026</p>
        </div>
    </div>

    <canvas id="bg"></canvas>

    <div id="ui-layer">
        <div id="scene-2025" class="absolute inset-0 flex flex-col items-center justify-center opacity-0">
            <h1 class="netflix-font text-6xl md:text-9xl netflix-red glow-red">2025</h1>
            <p class="text-white tracking-[1em] text-[10px] mt-2">FINALE</p>
        </div>
        <div id="scene-2026" class="absolute inset-0 flex flex-col items-center justify-center opacity-0 scale-150 px-6">
            <h1 class="netflix-font text-6xl md:text-[15rem] leading-none text-white glow-red">2026</h1>
            <div class="h-1 w-full max-w-md bg-[#E50914] shadow-[0_0_20px_#E50914] mt-2"></div>
        </div>
        <div id="credits" class="absolute top-full w-full flex flex-col items-center text-center">
            <div class="mb-32"><p class="text-[#E50914] text-[10px] tracking-widest mb-1 uppercase">Directed By</p><p class="text-white text-5xl md:text-7xl font-black">GOD</p></div>
            <div class="mb-32"><p class="text-[#E50914] text-[10px] tracking-widest mb-1 uppercase">Produced By</p><p class="text-white text-5xl md:text-7xl font-black">JESUS</p></div>
            <div class="mt-40 mb-96"><h2 class="netflix-font text-8xl netflix-red glow-red">2026</h2></div>
        </div>
    </div>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#bg'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        camera.position.z = 60;

        const particleCount = window.innerWidth < 768 ? 12000 : 20000;
        const geometry = new THREE.BufferGeometry();
        const pos = new Float32Array(particleCount * 3);
        const cols = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i++) {
            pos[i] = (Math.random() - 0.5) * 600;
            cols[i] = 1.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(cols, 3));
        const material = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, opacity: 0.9 });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        function getPoints(text, fontSize, isMobile) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1600; // Wider canvas for mobile safety
            canvas.height = 400;
            ctx.fillStyle = 'white';
            // Adjust scale based on screen
            const scale = isMobile ? 0.07 : 0.14; 
            ctx.font = `bold ${fontSize}px Bebas Neue`;
            ctx.textAlign = 'center';
            ctx.letterSpacing = isMobile ? "15px" : "2px"; // Force gap on mobile
            ctx.fillText(text, 800, 200);
            
            const data = ctx.getImageData(0, 0, 1600, 400).data;
            const pts = [];
            for (let y = 0; y < 400; y += 3) {
                for (let x = 0; x < 1600; x += 3) {
                    if (data[(y * 1600 + x) * 4] > 128) {
                        pts.push({ x: (x - 800) * scale, y: -(y - 200) * scale });
                    }
                }
            }
            return pts;
        }

        const isMobile = window.innerWidth < 768;
        const hiddenMsg = getPoints("GOD LOVE YOU ALL", isMobile ? 80 : 100, isMobile);
        const finalMsg = getPoints("GOOD NIGHT", isMobile ? 120 : 160, isMobile);

        const tl = gsap.timeline({ paused: true });
        let currentMode = 'drift'; 
        let speed = 0.5;

        tl.to("#start-screen", { opacity: 0, duration: 1, onComplete: () => document.getElementById('start-screen').remove() })
          .to("#scene-2025", { opacity: 1, duration: 2 })
          .to("#scene-2025", { opacity: 0, scale: 0.8, duration: 1.5 }, "+=1")
          .to({}, { duration: 1, onStart: () => { speed = 18; }, onComplete: () => { speed = 0.5; } })
          .to("#flash", { opacity: 1, duration: 0.1 }).to("#flash", { opacity: 0, duration: 1 })
          .to("#scene-2026", { opacity: 1, scale: 1, duration: 2, ease: "expo.out" })
          .to("#scene-2026", { opacity: 0, y: -100, duration: 2 }, "+=2.5")
          .to("#credits", { y: isMobile ? "-480vh" : "-420vh", duration: 18, ease: "none" })
          .to({}, { duration: 0.1, onStart: () => { currentMode = 'hidden'; }})
          .to({}, { duration: 1.2 }) // Subliminal timing
          .to({}, { duration: 0.1, onStart: () => { currentMode = 'final'; }})
          .to(camera.position, { z: isMobile ? 50 : 40, duration: 4, ease: "power2.inOut" });

        function animate() {
            requestAnimationFrame(animate);
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;

            if (currentMode === 'drift') {
                for (let i = 2; i < positions.length; i += 3) {
                    positions[i] += speed;
                    if (positions[i] > 100) positions[i] = -400;
                }
            } else {
                const targetSet = currentMode === 'hidden' ? hiddenMsg : finalMsg;
                const lerp = currentMode === 'hidden' ? 0.12 : 0.08;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    const target = targetSet[i % targetSet.length];
                    positions[i3] += (target.x - positions[i3]) * lerp;
                    positions[i3+1] += (target.y - positions[i3+1]) * lerp;
                    positions[i3+2] += (0 - positions[i3+2]) * lerp;
                    
                    if(currentMode === 'final') {
                        colors[i3] = 0.9; colors[i3+1] *= 0.94; colors[i3+2] *= 0.94;
                    }
                }
                geometry.attributes.color.needsUpdate = true;
            }
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        document.getElementById('start-screen').addEventListener('click', () => tl.play());
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>